import { NextRequest, NextResponse } from 'next/server'
import { Octokit } from '@octokit/rest'
import { supabase, supabaseAdmin } from '@/lib/supabase'

/**
 * Push generated code to GitHub repository
 * POST /api/github/push
 */
export async function POST(request: NextRequest) {
  try {
    const { project, repoName, description, isPrivate } = await request.json()

    if (!project || !project.files || !repoName) {
      return NextResponse.json(
        { error: 'Missing required parameters: project, repoName' },
        { status: 400 }
      )
    }

    // Get the session from the request
    const authHeader = request.headers.get('authorization')
    if (!authHeader) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      )
    }

    const token = authHeader.replace('Bearer ', '')

    if (!supabase) {
      return NextResponse.json(
        { error: 'Supabase not configured' },
        { status: 500 }
      )
    }

    const { data: { user }, error: userError } = await supabase.auth.getUser(token)

    if (userError || !user) {
      console.error('User verification error:', userError)
      return NextResponse.json(
        { error: 'Invalid session' },
        { status: 401 }
      )
    }

    // Get GitHub token from database
    if (!supabaseAdmin) {
      return NextResponse.json(
        { error: 'GitHub integration requires Supabase admin configuration. Please contact administrator.' },
        { status: 500 }
      )
    }

    const { data: tokenData, error: tokenError } = await supabaseAdmin
      .from('user_github_tokens')
      .select('github_token, github_username')
      .eq('user_id', user.id)
      .single()

    if (tokenError || !tokenData || !tokenData.github_token) {
      return NextResponse.json(
        { error: 'GitHub not connected. Please connect your GitHub account first.' },
        { status: 401 }
      )
    }

    // Initialize Octokit with user's GitHub token
    const octokit = new Octokit({
      auth: tokenData.github_token,
    })

    const githubUsername = tokenData.github_username

    // Create repository
    try {
      console.log(`Creating repository: ${repoName} for user: ${githubUsername}`)
      const { data: repo } = await octokit.repos.createForAuthenticatedUser({
        name: repoName,
        description: description || `Generated by mornFront - ${project.projectName}`,
        private: isPrivate || false,
        auto_init: true,  // Initialize with README to avoid empty repo issues
      })
      console.log(`Repository created: ${repo.html_url}`)

      // Get the initial commit SHA (created by auto_init)
      const { data: { object: { sha: initialCommitSha } } } = await octokit.git.getRef({
        owner: githubUsername,
        repo: repoName,
        ref: 'heads/main',
      })
      console.log(`Initial commit SHA: ${initialCommitSha}`)

      // Get the tree from the initial commit
      const { data: initialCommit } = await octokit.git.getCommit({
        owner: githubUsername,
        repo: repoName,
        commit_sha: initialCommitSha,
      })
      console.log(`Initial commit tree SHA: ${initialCommit.tree.sha}`)

      // Create all files in the repository
      const files = Object.entries(project.files)
      console.log(`Creating ${files.length} files in repository`)

      // First, create blobs for each file
      const treeItems: Array<{ path: string; mode: string; type: string; sha?: string }> = []

      for (const [filePath, content] of files) {
        try {
          console.log(`Creating blob for ${filePath} (${content.length} chars)`)
          // Create a blob for each file
          const blob = await octokit.git.createBlob({
            owner: githubUsername,
            repo: repoName,
            content: Buffer.from(content).toString('base64'),
            encoding: 'base64',
          })

          treeItems.push({
            path: filePath,
            mode: '100644',
            type: 'blob',
            sha: blob.data.sha,
          })
          console.log(`Blob created for ${filePath}: ${blob.data.sha}`)
        } catch (blobError: any) {
          console.error(`Error creating blob for ${filePath}:`, blobError)
          throw blobError
        }
      }

      console.log(`Created ${treeItems.length} tree items`)

      // Create the tree with blob references
      console.log('Creating tree...')
      const tree = await octokit.git.createTree({
        owner: githubUsername,
        repo: repoName,
        tree: treeItems,
        base_tree: initialCommit.tree.sha,  // Use initial commit's tree as base
      })
      console.log(`Tree created: ${tree.data.sha}`)

      // Create commit
      console.log('Creating commit...')
      const commit = await octokit.git.createCommit({
        owner: githubUsername,
        repo: repoName,
        message: 'Initial commit: Generated by mornFront',
        tree: tree.data.sha,
        parents: [initialCommitSha],  // Use initial commit as parent
      })
      console.log(`Commit created: ${commit.data.sha}`)

      // Update default branch to point to the new commit
      console.log('Updating default branch...')
      await octokit.git.updateRef({
        owner: githubUsername,
        repo: repoName,
        ref: 'heads/main',
        sha: commit.data.sha,
        force: true,
      })
      console.log('Branch updated successfully')

      return NextResponse.json({
        success: true,
        repoUrl: repo.html_url,
        cloneUrl: repo.clone_url,
        message: 'Successfully pushed to GitHub!',
      })
    } catch (repoError: any) {
      // If repository already exists, try to update it
      if (repoError.status === 422 && repoError.message?.includes('already exists')) {
        // Repository exists, we need to create a new branch or update existing files
        // For simplicity, we'll return an error asking user to choose a different name
        return NextResponse.json(
          { error: `Repository "${repoName}" already exists. Please choose a different name.` },
          { status: 409 }
        )
      }
      throw repoError
    }
  } catch (error: any) {
    console.error('Error pushing to GitHub:', error)
    return NextResponse.json(
      { error: error.message || 'Failed to push to GitHub' },
      { status: 500 }
    )
  }
}

